1.数据库设计要合理(3F)
2.添加索引(普通索引，主键索引，唯一索引，全文索引)
3.分表分库技术(取模分表,水平分割,垂直分割)
4.读写分离
5.存储过程
6.配置mysql最大连接数()my.ini
7.mysql服务器升级
8.随时清理碎片化
9.sql语句调优(最重要)




****************************************************************************************
数据库设计
什么是数据设计 （减少冗余量，3F）
什么是数据库三大范式
1F 原子约束 每列不可再分
id  name  sex   addres
1   张三   0      上海
名字和性别不可再分
是否保证原子性（看业务）

2F 保证唯一性，主键
id  ordernum(唯一) name  sex   addres
1                   张三   0      上海
1.订单表中id不能作为订单号
  项目内部远程调用id外部调用ordernum
2.分布式系统解决并发产生订单号
  保证抢票中，订单号不会重复产生（怎么保证订单的幂等性）(幂等的意思就是不会重复产生)
  方法：提前将订单号生成好，存放在redis中，需要我直接去redis中取。
        分布锁
3F 不要有冗余数据
一个表的某个字段有多个相同的数据，可以把这个再分一张表，将那个字段放在这张表中

但是不一定要遵循3F
因为有些时候业务需求，虽然有的数据相同，但是我就是需要这样的数据，分出这个字段后就很麻烦





**********************************************************************************************
分库分表
什么时候分库
电商项目将一个项目进行拆分，每一个小的项目有自己的单独数据库。
互不影响---垂直分割 会员数据库，订单数据库，支付宝数据库
-------------------------------------------------------
什么时候分表
水平分割 分表 更具业务需求 存放日志（每年存放） 更具年份表，
腾讯QQ号 位数（缺点），不均匀

6条数据放在3张表中，怎么非常均匀 取模算法
id作为递增唯一标识符，id数除以分表数取余，余数就作为放在存放在哪张表的基准

分表之后有什么缺点：1.分页查询 2.查询非常受限制
解决方法，先主表，存放所有数据  根据具体业务需求进行分表
取模算法 如果表发生了变化，id也发生变化，就不好解决

rds 阿里云数据库，自带分表，分库，解决高并发查询功能







************************************************************************************
什么是慢查询？
mysql默认慢查询时间为10s，超过该时间默认为慢查询
慢查询都会有日志存放，我们可以在执行完语句过后到日志中查看哪条语句是慢查询

show status
使用show status 查看mysql服务器状态信息
常用命令
--mysql数据库启动了多少时间
show status like 'uptime';
--显示数据库的查询，更新，添加，删除的次数
show status like 'com_select' 类推'com_insert' 'com_update' 'com_delete'
--如果不写[session|global】默认是session会话,指取出当前窗口的执行，如果你想看
所有（从mysql启动到现在,则应该是global）
show [session|global] status like
--显示到mysql数据库的连接数
show status like 'connections';
--显示慢查询次数
show staus like 'slow_queries';
--查询慢查询时间
show variables like 'long_query_time';
--修改慢查询时间
set long_query_time=1;--但是重启mysql过后，long_query_time依然是my.ini的值

--如何将慢查询定位到日志中
在默认情况下，mysql不会记录慢查询，需要在启动mysql的时候，指定慢查询才可以，
bin\mysqld.exe --safe-mode --slow-query-log [mysql5.5 可以在my.inin指定]
(安全模式启动，数据库将操作写入日志，以备恢复)（bin\不用输入）
bin\mysqld.exe -log-slow-queries=d:/abc.log[低版本mysql5.0可以在my.ini指定]
先在服务中关闭mysql，在cmd以安全模式加日志再启动,如果启动了慢查询日志，默认把这个文件放在my.ini
文件中记录的位置
#path to the database root
datadir='datadir=D:\mysql\mysql-5.6.38-winx64\mysql-5.6.38-winx64\data'








*************************************************************************************************
索引
为什么要索引？---提高查询效率
为什么加了索引能够提高查询效率？---索引实现原理
索引底层采用b-tree 折半查找 二分查找
索引文件会像一个树状一样进行存放
b-tree可以查找2的N次方
索引有什么缺点：增加，删除时，数据发生变化，但是索引文件没有改变，
所以索引文件也需要更新

唯一索引
在表结构的字段中加了unique就是唯一索引。唯一索引用的不多，因为被主键索引代替了，
主键索引有一样的作用
注意：
unique字段可以为null，并可以有多null,但是如果是具体内容，则不能重复，
但是不能存在重复的空字符串' '

普通索引
普通索引（由关键字KEY或index定义的索引）的唯一任务是加快对数据的访问速度，
因此，应该只为那些经常出现在查询条件where或排序条件orderby中的数据列创建索引。
只要有可能，就应该选择一个数据最整齐，最紧凑的数据列（如一个整数类型的数据列）来创建索引
create index 索引名 on 表（列1，列名2）
---执行计划
在查询语句前加上explain
explain select * from user where id='1'
不加索引字段为查询条件就不会产生效果
结果中有一个type类型，const代表索引文件，all代表全表扫描，
key代表索引的类型，rows代表索引的行数

全文索引






*********************************************************************
索引优缺点
优点：提高程序效率
缺点：增加，删除慢，因为索引文件需要更新，增加内存

什么字段适合加索引
select * from user where sex='男'; 
---不需要，因为sex只有两种类型
select * from user where id=11;
---需要，因为查询次数比较多，值不同
建立索引where条件需要查询，并且值非常多不同，
唯一几个值，不需要建立索引

索引注意事项：
---创建组合索引
alter table user add index my_index (id,name);
1.如果使用组合索引
第一个可以不用第二个一起作为条件查询--会使用组合索引进行查找
使用第二个条件，不使用第一个条件--不会使用组合索引进行查找
使用第一个和第二个条件一起查找，使用索引进行查找
2.条件加like的效果
使用索引的时候，不要like '%%'否则使用全表扫描
使用like '%'，百分号在前,不会使用索引查找,
使用like '   %',百分号在后,会使用索引查找
3.使用or,条件都必须加上索引，只要有一个条件不加索引，不会使用索引查找
4.判断是否为null，使用is null，会使用索引查询，使用=null,不会使用索引查询
5.group by 分组不会使用索引，全表扫描
6.分组需要效率高，禁止排序，order by null
7.select * from user >= 100;
select * from user > 100;
尽量不要使用>=，大于会使用一次全表扫描，等于还会使用一次全表扫描




*********************************************************************************
SQL 优化技巧
1.使用group by 分组查询时，默认分组后，还会排序，可能会降低速度，在group by后面增加order by null 就可以防止排序
explain select * from user group by name order by null
2.有些情况下，可以使用连接来代替子查询，因为使用join，mysql不需要在内存中创建临时表
select * from user,orders where user.num=orders.num[简单处理方式]
select * from user left join orders on user.num=orders.num;[左外连接更好]
3.对查询进行优化，要尽量避免全表扫描，首先应考虑在where及order by涉及到的列上建立索引
应尽量避免在where子句中对字段进行null值判断,否则将导致引擎放弃使用索引而是进行全表扫描，
比如select * from t wherer num is null
最好不要给数据库留null，尽可能使用not null填充数据库
备注，描述，评论之类的设置可以设置为null，其他的，最好不要使用null
不要以为null不需要空间，比如char(100)型,在字段建立时，空间就固定了，不管是否插入值（null也包含在内）
都是占用100个字符的空间，如果是varchar这种变长字段，null不占用空间
可以在num上设置默认值0，确保表中num列没有null，然后这样查询
比如：select * from t where num =0


